// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mainchain/beacon/v1/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgRegisterBeacon represents a message to register a new beacon
type MsgRegisterBeacon struct {
	// moniker is a short identifier for a beacon
	Moniker string `protobuf:"bytes,1,opt,name=moniker,proto3" json:"moniker,omitempty"`
	// name is a long name for a beacon
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// owner is the address of the owner of the beacon
	Owner string `protobuf:"bytes,3,opt,name=owner,proto3" json:"owner,omitempty"`
}

func (m *MsgRegisterBeacon) Reset()         { *m = MsgRegisterBeacon{} }
func (m *MsgRegisterBeacon) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterBeacon) ProtoMessage()    {}
func (*MsgRegisterBeacon) Descriptor() ([]byte, []int) {
	return fileDescriptor_e58884c800f582f9, []int{0}
}
func (m *MsgRegisterBeacon) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterBeacon) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterBeacon.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterBeacon) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterBeacon.Merge(m, src)
}
func (m *MsgRegisterBeacon) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterBeacon) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterBeacon.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterBeacon proto.InternalMessageInfo

// MsgRegisterBeaconResponse defines the Msg/RegisterBeacon response type.
type MsgRegisterBeaconResponse struct {
	// beacon_id is the id of the new beacon
	BeaconId uint64 `protobuf:"varint,1,opt,name=beacon_id,json=beaconId,proto3" json:"beacon_id,omitempty"`
}

func (m *MsgRegisterBeaconResponse) Reset()         { *m = MsgRegisterBeaconResponse{} }
func (m *MsgRegisterBeaconResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterBeaconResponse) ProtoMessage()    {}
func (*MsgRegisterBeaconResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e58884c800f582f9, []int{1}
}
func (m *MsgRegisterBeaconResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterBeaconResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterBeaconResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterBeaconResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterBeaconResponse.Merge(m, src)
}
func (m *MsgRegisterBeaconResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterBeaconResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterBeaconResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterBeaconResponse proto.InternalMessageInfo

func (m *MsgRegisterBeaconResponse) GetBeaconId() uint64 {
	if m != nil {
		return m.BeaconId
	}
	return 0
}

// MsgRecordBeaconTimestamp represents a message to record a timestamp for a registered beacon
type MsgRecordBeaconTimestamp struct {
	// beacon_id is the id of the beacon the timestamp is being submitted for
	BeaconId uint64 `protobuf:"varint,1,opt,name=beacon_id,json=beaconId,proto3" json:"beacon_id,omitempty"`
	// hash is the hash or data being submitted
	Hash string `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	// submit_time is a unix epoch value of the submission time
	SubmitTime uint64 `protobuf:"varint,3,opt,name=submit_time,json=submitTime,proto3" json:"submit_time,omitempty"`
	// owner is the address of the owner of the beacon
	Owner string `protobuf:"bytes,4,opt,name=owner,proto3" json:"owner,omitempty"`
}

func (m *MsgRecordBeaconTimestamp) Reset()         { *m = MsgRecordBeaconTimestamp{} }
func (m *MsgRecordBeaconTimestamp) String() string { return proto.CompactTextString(m) }
func (*MsgRecordBeaconTimestamp) ProtoMessage()    {}
func (*MsgRecordBeaconTimestamp) Descriptor() ([]byte, []int) {
	return fileDescriptor_e58884c800f582f9, []int{2}
}
func (m *MsgRecordBeaconTimestamp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRecordBeaconTimestamp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRecordBeaconTimestamp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRecordBeaconTimestamp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRecordBeaconTimestamp.Merge(m, src)
}
func (m *MsgRecordBeaconTimestamp) XXX_Size() int {
	return m.Size()
}
func (m *MsgRecordBeaconTimestamp) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRecordBeaconTimestamp.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRecordBeaconTimestamp proto.InternalMessageInfo

// MsgRecordBeaconTimestampResponse defines the Msg/RecordBeacon response type.
type MsgRecordBeaconTimestampResponse struct {
	// beacon_id is the id of the beacon
	BeaconId uint64 `protobuf:"varint,1,opt,name=beacon_id,json=beaconId,proto3" json:"beacon_id,omitempty"`
	// timestamp_id is the id of the new timestamp
	TimestampId uint64 `protobuf:"varint,2,opt,name=timestamp_id,json=timestampId,proto3" json:"timestamp_id,omitempty"`
}

func (m *MsgRecordBeaconTimestampResponse) Reset()         { *m = MsgRecordBeaconTimestampResponse{} }
func (m *MsgRecordBeaconTimestampResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRecordBeaconTimestampResponse) ProtoMessage()    {}
func (*MsgRecordBeaconTimestampResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e58884c800f582f9, []int{3}
}
func (m *MsgRecordBeaconTimestampResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRecordBeaconTimestampResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRecordBeaconTimestampResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRecordBeaconTimestampResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRecordBeaconTimestampResponse.Merge(m, src)
}
func (m *MsgRecordBeaconTimestampResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRecordBeaconTimestampResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRecordBeaconTimestampResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRecordBeaconTimestampResponse proto.InternalMessageInfo

func (m *MsgRecordBeaconTimestampResponse) GetBeaconId() uint64 {
	if m != nil {
		return m.BeaconId
	}
	return 0
}

func (m *MsgRecordBeaconTimestampResponse) GetTimestampId() uint64 {
	if m != nil {
		return m.TimestampId
	}
	return 0
}

// MsgPurchaseBeaconStateStorage represents a message to purchase more beacon storage
type MsgPurchaseBeaconStateStorage struct {
	// beacon_id is the id of the beacon the storage is being purchased for
	BeaconId uint64 `protobuf:"varint,1,opt,name=beacon_id,json=beaconId,proto3" json:"beacon_id,omitempty"`
	// number is the number of state storage spaces to purchase
	Number uint64 `protobuf:"varint,2,opt,name=number,proto3" json:"number,omitempty"`
	// owner is the address of the owner of the beacon
	Owner string `protobuf:"bytes,3,opt,name=owner,proto3" json:"owner,omitempty"`
}

func (m *MsgPurchaseBeaconStateStorage) Reset()         { *m = MsgPurchaseBeaconStateStorage{} }
func (m *MsgPurchaseBeaconStateStorage) String() string { return proto.CompactTextString(m) }
func (*MsgPurchaseBeaconStateStorage) ProtoMessage()    {}
func (*MsgPurchaseBeaconStateStorage) Descriptor() ([]byte, []int) {
	return fileDescriptor_e58884c800f582f9, []int{4}
}
func (m *MsgPurchaseBeaconStateStorage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPurchaseBeaconStateStorage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPurchaseBeaconStateStorage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPurchaseBeaconStateStorage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPurchaseBeaconStateStorage.Merge(m, src)
}
func (m *MsgPurchaseBeaconStateStorage) XXX_Size() int {
	return m.Size()
}
func (m *MsgPurchaseBeaconStateStorage) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPurchaseBeaconStateStorage.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPurchaseBeaconStateStorage proto.InternalMessageInfo

// MsgPurchaseBeaconStateStorageResponse defines the Msg/PurchaseBeaconStateStorage response type.
type MsgPurchaseBeaconStateStorageResponse struct {
	// beacon_id is the id of the beacon the storage is being purchased for
	BeaconId uint64 `protobuf:"varint,1,opt,name=beacon_id,json=beaconId,proto3" json:"beacon_id,omitempty"`
	// number_purchased is the number of state storage spaces purchased
	NumberPurchased uint64 `protobuf:"varint,2,opt,name=number_purchased,json=numberPurchased,proto3" json:"number_purchased,omitempty"`
	// num_can_purchase is the number of remaining slots available for purchase
	NumCanPurchase uint64 `protobuf:"varint,3,opt,name=num_can_purchase,json=numCanPurchase,proto3" json:"num_can_purchase,omitempty"`
}

func (m *MsgPurchaseBeaconStateStorageResponse) Reset()         { *m = MsgPurchaseBeaconStateStorageResponse{} }
func (m *MsgPurchaseBeaconStateStorageResponse) String() string { return proto.CompactTextString(m) }
func (*MsgPurchaseBeaconStateStorageResponse) ProtoMessage()    {}
func (*MsgPurchaseBeaconStateStorageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e58884c800f582f9, []int{5}
}
func (m *MsgPurchaseBeaconStateStorageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPurchaseBeaconStateStorageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPurchaseBeaconStateStorageResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPurchaseBeaconStateStorageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPurchaseBeaconStateStorageResponse.Merge(m, src)
}
func (m *MsgPurchaseBeaconStateStorageResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgPurchaseBeaconStateStorageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPurchaseBeaconStateStorageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPurchaseBeaconStateStorageResponse proto.InternalMessageInfo

func (m *MsgPurchaseBeaconStateStorageResponse) GetBeaconId() uint64 {
	if m != nil {
		return m.BeaconId
	}
	return 0
}

func (m *MsgPurchaseBeaconStateStorageResponse) GetNumberPurchased() uint64 {
	if m != nil {
		return m.NumberPurchased
	}
	return 0
}

func (m *MsgPurchaseBeaconStateStorageResponse) GetNumCanPurchase() uint64 {
	if m != nil {
		return m.NumCanPurchase
	}
	return 0
}

func init() {
	proto.RegisterType((*MsgRegisterBeacon)(nil), "mainchain.beacon.v1.MsgRegisterBeacon")
	proto.RegisterType((*MsgRegisterBeaconResponse)(nil), "mainchain.beacon.v1.MsgRegisterBeaconResponse")
	proto.RegisterType((*MsgRecordBeaconTimestamp)(nil), "mainchain.beacon.v1.MsgRecordBeaconTimestamp")
	proto.RegisterType((*MsgRecordBeaconTimestampResponse)(nil), "mainchain.beacon.v1.MsgRecordBeaconTimestampResponse")
	proto.RegisterType((*MsgPurchaseBeaconStateStorage)(nil), "mainchain.beacon.v1.MsgPurchaseBeaconStateStorage")
	proto.RegisterType((*MsgPurchaseBeaconStateStorageResponse)(nil), "mainchain.beacon.v1.MsgPurchaseBeaconStateStorageResponse")
}

func init() { proto.RegisterFile("mainchain/beacon/v1/tx.proto", fileDescriptor_e58884c800f582f9) }

var fileDescriptor_e58884c800f582f9 = []byte{
	// 548 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x54, 0xbf, 0x6f, 0xd3, 0x40,
	0x14, 0x8e, 0xd3, 0x50, 0xe8, 0x2b, 0x2a, 0x70, 0x14, 0x70, 0x0d, 0x38, 0x25, 0x12, 0xa8, 0x20,
	0xc5, 0x56, 0x5b, 0x21, 0xa1, 0x6e, 0x84, 0xa9, 0x43, 0x24, 0xe4, 0x30, 0xb1, 0x44, 0x67, 0xfb,
	0x38, 0x9f, 0xd0, 0xdd, 0x45, 0xbe, 0x73, 0x29, 0x03, 0x0b, 0x12, 0x12, 0x03, 0x03, 0x23, 0x6c,
	0xfd, 0x13, 0x3a, 0xf0, 0x47, 0x30, 0x56, 0x4c, 0x8c, 0x28, 0x19, 0xe0, 0x9f, 0x40, 0x42, 0xf6,
	0xd9, 0xa9, 0x44, 0x93, 0x90, 0xa2, 0x6e, 0xf7, 0xbe, 0xf7, 0xbd, 0xf7, 0xbe, 0xef, 0x7e, 0xc1,
	0x2d, 0x8e, 0x99, 0x88, 0x12, 0xcc, 0x84, 0x1f, 0x12, 0x1c, 0x49, 0xe1, 0xef, 0x6d, 0xfa, 0x7a,
	0xdf, 0x1b, 0xa4, 0x52, 0x4b, 0x74, 0x75, 0x9c, 0xf5, 0x4c, 0xd6, 0xdb, 0xdb, 0x74, 0x6e, 0x44,
	0x52, 0x71, 0xa9, 0x7c, 0xae, 0x68, 0x4e, 0xe6, 0x8a, 0x1a, 0xb6, 0xb3, 0x66, 0x12, 0xfd, 0x22,
	0xf2, 0x4d, 0x50, 0xa6, 0x56, 0xa9, 0xa4, 0xd2, 0xe0, 0xf9, 0xca, 0xa0, 0xad, 0x77, 0x16, 0x5c,
	0xe9, 0x2a, 0x1a, 0x10, 0xca, 0x94, 0x26, 0x69, 0xa7, 0x18, 0x81, 0x6c, 0x38, 0xcf, 0xa5, 0x60,
	0x2f, 0x49, 0x6a, 0x5b, 0xeb, 0xd6, 0xc6, 0x52, 0x50, 0x85, 0x08, 0x41, 0x43, 0x60, 0x4e, 0xec,
	0x7a, 0x01, 0x17, 0x6b, 0xe4, 0xc1, 0x39, 0xf9, 0x4a, 0x90, 0xd4, 0x5e, 0xc8, 0xc1, 0x8e, 0xfd,
	0xed, 0x4b, 0x7b, 0xb5, 0x1c, 0xfd, 0x38, 0x8e, 0x53, 0xa2, 0x54, 0x4f, 0xa7, 0x4c, 0xd0, 0xc0,
	0xd0, 0x76, 0xd0, 0xfb, 0x83, 0x66, 0xed, 0xd7, 0x41, 0xb3, 0xf6, 0xf6, 0xe7, 0xe1, 0x03, 0x83,
	0xb5, 0x1e, 0xc1, 0xda, 0x09, 0x19, 0x01, 0x51, 0x03, 0x29, 0x14, 0x41, 0x37, 0x61, 0xc9, 0x78,
	0xef, 0xb3, 0xb8, 0x10, 0xd4, 0x08, 0x2e, 0x18, 0x60, 0x37, 0x6e, 0x1d, 0x5a, 0x60, 0x17, 0xa5,
	0x91, 0x4c, 0x63, 0x53, 0xf8, 0x8c, 0x71, 0xa2, 0x34, 0xe6, 0x83, 0x99, 0x95, 0xb9, 0x97, 0x04,
	0xab, 0xa4, 0xf2, 0x92, 0xaf, 0x51, 0x13, 0x96, 0x55, 0x16, 0x72, 0xa6, 0xfb, 0x9a, 0x71, 0x52,
	0x38, 0x6a, 0x04, 0x60, 0xa0, 0xbc, 0xed, 0xb1, 0xd9, 0xc6, 0xff, 0x9b, 0x0d, 0x61, 0x7d, 0x9a,
	0xe2, 0xb9, 0x3c, 0xa3, 0x3b, 0x70, 0x51, 0x57, 0x15, 0x79, 0xbe, 0x5e, 0xe4, 0x97, 0xc7, 0xd8,
	0x6e, 0xdc, 0xfa, 0x64, 0xc1, 0xed, 0xae, 0xa2, 0x4f, 0xb3, 0x34, 0x4a, 0xb0, 0x22, 0x66, 0x4c,
	0x4f, 0x63, 0x4d, 0x7a, 0x5a, 0xa6, 0x98, 0xfe, 0x63, 0xc2, 0x75, 0x58, 0x14, 0x19, 0x0f, 0x49,
	0x5a, 0xf6, 0x2e, 0xa3, 0x33, 0x39, 0xeb, 0xcf, 0x16, 0xdc, 0x9d, 0x29, 0x6d, 0xbe, 0x4d, 0xb8,
	0x0f, 0x97, 0x8d, 0xa8, 0xfe, 0xa0, 0xec, 0x54, 0x6d, 0xc4, 0x25, 0x83, 0x57, 0x03, 0x62, 0xb4,
	0x51, 0x50, 0xfb, 0x11, 0x16, 0x63, 0x6e, 0x79, 0xb4, 0x2b, 0x22, 0xe3, 0x4f, 0xb0, 0xa8, 0xa8,
	0x5b, 0xbf, 0xeb, 0xb0, 0xd0, 0x55, 0x14, 0x25, 0xb0, 0xf2, 0xd7, 0x9b, 0xb8, 0xe7, 0x4d, 0x78,
	0x89, 0xde, 0x89, 0x4b, 0xeb, 0x78, 0xf3, 0xf1, 0xc6, 0x1e, 0xdf, 0xc0, 0xb5, 0xc9, 0x77, 0xb7,
	0x3d, 0xbd, 0xd1, 0x04, 0xba, 0xf3, 0xf0, 0x54, 0xf4, 0xf1, 0xf8, 0x0f, 0x16, 0x38, 0x33, 0x2e,
	0xc9, 0xd6, 0xb4, 0xae, 0xd3, 0x6b, 0x9c, 0x9d, 0xd3, 0xd7, 0x54, 0x72, 0x3a, 0xdd, 0xaf, 0x43,
	0xd7, 0x3a, 0x1a, 0xba, 0xd6, 0x8f, 0xa1, 0x6b, 0x7d, 0x1c, 0xb9, 0xb5, 0xa3, 0x91, 0x5b, 0xfb,
	0x3e, 0x72, 0x6b, 0xcf, 0xb7, 0x29, 0xd3, 0x49, 0x16, 0x7a, 0x91, 0xe4, 0x7e, 0x26, 0xd8, 0x0b,
	0x16, 0x61, 0xcd, 0xa4, 0x68, 0xe7, 0xf1, 0xf1, 0x0f, 0xba, 0x5f, 0xfd, 0xa1, 0xfa, 0xf5, 0x80,
	0xa8, 0x70, 0xb1, 0xf8, 0xe5, 0xb6, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0x2f, 0xea, 0xae, 0x18,
	0x64, 0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// RegisterBeacon defines a method to register a new beacon
	RegisterBeacon(ctx context.Context, in *MsgRegisterBeacon, opts ...grpc.CallOption) (*MsgRegisterBeaconResponse, error)
	// RecordBeaconTimestamp defines a method to record a timestamp for a registered beacon
	RecordBeaconTimestamp(ctx context.Context, in *MsgRecordBeaconTimestamp, opts ...grpc.CallOption) (*MsgRecordBeaconTimestampResponse, error)
	// PurchaseBeaconStateStorage defines the method to purchase more state storage
	PurchaseBeaconStateStorage(ctx context.Context, in *MsgPurchaseBeaconStateStorage, opts ...grpc.CallOption) (*MsgPurchaseBeaconStateStorageResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) RegisterBeacon(ctx context.Context, in *MsgRegisterBeacon, opts ...grpc.CallOption) (*MsgRegisterBeaconResponse, error) {
	out := new(MsgRegisterBeaconResponse)
	err := c.cc.Invoke(ctx, "/mainchain.beacon.v1.Msg/RegisterBeacon", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RecordBeaconTimestamp(ctx context.Context, in *MsgRecordBeaconTimestamp, opts ...grpc.CallOption) (*MsgRecordBeaconTimestampResponse, error) {
	out := new(MsgRecordBeaconTimestampResponse)
	err := c.cc.Invoke(ctx, "/mainchain.beacon.v1.Msg/RecordBeaconTimestamp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) PurchaseBeaconStateStorage(ctx context.Context, in *MsgPurchaseBeaconStateStorage, opts ...grpc.CallOption) (*MsgPurchaseBeaconStateStorageResponse, error) {
	out := new(MsgPurchaseBeaconStateStorageResponse)
	err := c.cc.Invoke(ctx, "/mainchain.beacon.v1.Msg/PurchaseBeaconStateStorage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// RegisterBeacon defines a method to register a new beacon
	RegisterBeacon(context.Context, *MsgRegisterBeacon) (*MsgRegisterBeaconResponse, error)
	// RecordBeaconTimestamp defines a method to record a timestamp for a registered beacon
	RecordBeaconTimestamp(context.Context, *MsgRecordBeaconTimestamp) (*MsgRecordBeaconTimestampResponse, error)
	// PurchaseBeaconStateStorage defines the method to purchase more state storage
	PurchaseBeaconStateStorage(context.Context, *MsgPurchaseBeaconStateStorage) (*MsgPurchaseBeaconStateStorageResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) RegisterBeacon(ctx context.Context, req *MsgRegisterBeacon) (*MsgRegisterBeaconResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterBeacon not implemented")
}
func (*UnimplementedMsgServer) RecordBeaconTimestamp(ctx context.Context, req *MsgRecordBeaconTimestamp) (*MsgRecordBeaconTimestampResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecordBeaconTimestamp not implemented")
}
func (*UnimplementedMsgServer) PurchaseBeaconStateStorage(ctx context.Context, req *MsgPurchaseBeaconStateStorage) (*MsgPurchaseBeaconStateStorageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PurchaseBeaconStateStorage not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_RegisterBeacon_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRegisterBeacon)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RegisterBeacon(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mainchain.beacon.v1.Msg/RegisterBeacon",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RegisterBeacon(ctx, req.(*MsgRegisterBeacon))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RecordBeaconTimestamp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRecordBeaconTimestamp)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RecordBeaconTimestamp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mainchain.beacon.v1.Msg/RecordBeaconTimestamp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RecordBeaconTimestamp(ctx, req.(*MsgRecordBeaconTimestamp))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_PurchaseBeaconStateStorage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgPurchaseBeaconStateStorage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).PurchaseBeaconStateStorage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mainchain.beacon.v1.Msg/PurchaseBeaconStateStorage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).PurchaseBeaconStateStorage(ctx, req.(*MsgPurchaseBeaconStateStorage))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mainchain.beacon.v1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterBeacon",
			Handler:    _Msg_RegisterBeacon_Handler,
		},
		{
			MethodName: "RecordBeaconTimestamp",
			Handler:    _Msg_RecordBeaconTimestamp_Handler,
		},
		{
			MethodName: "PurchaseBeaconStateStorage",
			Handler:    _Msg_PurchaseBeaconStateStorage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mainchain/beacon/v1/tx.proto",
}

func (m *MsgRegisterBeacon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterBeacon) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterBeacon) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Moniker) > 0 {
		i -= len(m.Moniker)
		copy(dAtA[i:], m.Moniker)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Moniker)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRegisterBeaconResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterBeaconResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterBeaconResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BeaconId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.BeaconId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgRecordBeaconTimestamp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRecordBeaconTimestamp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRecordBeaconTimestamp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x22
	}
	if m.SubmitTime != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SubmitTime))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x12
	}
	if m.BeaconId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.BeaconId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgRecordBeaconTimestampResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRecordBeaconTimestampResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRecordBeaconTimestampResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TimestampId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TimestampId))
		i--
		dAtA[i] = 0x10
	}
	if m.BeaconId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.BeaconId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgPurchaseBeaconStateStorage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPurchaseBeaconStateStorage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPurchaseBeaconStateStorage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Number != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Number))
		i--
		dAtA[i] = 0x10
	}
	if m.BeaconId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.BeaconId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgPurchaseBeaconStateStorageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPurchaseBeaconStateStorageResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPurchaseBeaconStateStorageResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NumCanPurchase != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.NumCanPurchase))
		i--
		dAtA[i] = 0x18
	}
	if m.NumberPurchased != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.NumberPurchased))
		i--
		dAtA[i] = 0x10
	}
	if m.BeaconId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.BeaconId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgRegisterBeacon) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Moniker)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRegisterBeaconResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BeaconId != 0 {
		n += 1 + sovTx(uint64(m.BeaconId))
	}
	return n
}

func (m *MsgRecordBeaconTimestamp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BeaconId != 0 {
		n += 1 + sovTx(uint64(m.BeaconId))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.SubmitTime != 0 {
		n += 1 + sovTx(uint64(m.SubmitTime))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRecordBeaconTimestampResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BeaconId != 0 {
		n += 1 + sovTx(uint64(m.BeaconId))
	}
	if m.TimestampId != 0 {
		n += 1 + sovTx(uint64(m.TimestampId))
	}
	return n
}

func (m *MsgPurchaseBeaconStateStorage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BeaconId != 0 {
		n += 1 + sovTx(uint64(m.BeaconId))
	}
	if m.Number != 0 {
		n += 1 + sovTx(uint64(m.Number))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgPurchaseBeaconStateStorageResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BeaconId != 0 {
		n += 1 + sovTx(uint64(m.BeaconId))
	}
	if m.NumberPurchased != 0 {
		n += 1 + sovTx(uint64(m.NumberPurchased))
	}
	if m.NumCanPurchase != 0 {
		n += 1 + sovTx(uint64(m.NumCanPurchase))
	}
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgRegisterBeacon) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterBeacon: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterBeacon: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Moniker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Moniker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterBeaconResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterBeaconResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterBeaconResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeaconId", wireType)
			}
			m.BeaconId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeaconId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRecordBeaconTimestamp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRecordBeaconTimestamp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRecordBeaconTimestamp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeaconId", wireType)
			}
			m.BeaconId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeaconId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmitTime", wireType)
			}
			m.SubmitTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubmitTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRecordBeaconTimestampResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRecordBeaconTimestampResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRecordBeaconTimestampResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeaconId", wireType)
			}
			m.BeaconId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeaconId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampId", wireType)
			}
			m.TimestampId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPurchaseBeaconStateStorage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPurchaseBeaconStateStorage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPurchaseBeaconStateStorage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeaconId", wireType)
			}
			m.BeaconId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeaconId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPurchaseBeaconStateStorageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPurchaseBeaconStateStorageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPurchaseBeaconStateStorageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeaconId", wireType)
			}
			m.BeaconId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeaconId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberPurchased", wireType)
			}
			m.NumberPurchased = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberPurchased |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumCanPurchase", wireType)
			}
			m.NumCanPurchase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumCanPurchase |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
